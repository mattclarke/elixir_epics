// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_VALUE: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_VALUE: u8 = 20;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_VALUE: [Value; 21] = [
  Value::NONE,
  Value::Byte,
  Value::UByte,
  Value::Short,
  Value::UShort,
  Value::Int,
  Value::UInt,
  Value::Long,
  Value::ULong,
  Value::Float,
  Value::Double,
  Value::ArrayByte,
  Value::ArrayUByte,
  Value::ArrayShort,
  Value::ArrayUShort,
  Value::ArrayInt,
  Value::ArrayUInt,
  Value::ArrayLong,
  Value::ArrayULong,
  Value::ArrayFloat,
  Value::ArrayDouble,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Value(pub u8);
#[allow(non_upper_case_globals)]
impl Value {
  pub const NONE: Self = Self(0);
  pub const Byte: Self = Self(1);
  pub const UByte: Self = Self(2);
  pub const Short: Self = Self(3);
  pub const UShort: Self = Self(4);
  pub const Int: Self = Self(5);
  pub const UInt: Self = Self(6);
  pub const Long: Self = Self(7);
  pub const ULong: Self = Self(8);
  pub const Float: Self = Self(9);
  pub const Double: Self = Self(10);
  pub const ArrayByte: Self = Self(11);
  pub const ArrayUByte: Self = Self(12);
  pub const ArrayShort: Self = Self(13);
  pub const ArrayUShort: Self = Self(14);
  pub const ArrayInt: Self = Self(15);
  pub const ArrayUInt: Self = Self(16);
  pub const ArrayLong: Self = Self(17);
  pub const ArrayULong: Self = Self(18);
  pub const ArrayFloat: Self = Self(19);
  pub const ArrayDouble: Self = Self(20);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 20;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::Byte,
    Self::UByte,
    Self::Short,
    Self::UShort,
    Self::Int,
    Self::UInt,
    Self::Long,
    Self::ULong,
    Self::Float,
    Self::Double,
    Self::ArrayByte,
    Self::ArrayUByte,
    Self::ArrayShort,
    Self::ArrayUShort,
    Self::ArrayInt,
    Self::ArrayUInt,
    Self::ArrayLong,
    Self::ArrayULong,
    Self::ArrayFloat,
    Self::ArrayDouble,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::Byte => Some("Byte"),
      Self::UByte => Some("UByte"),
      Self::Short => Some("Short"),
      Self::UShort => Some("UShort"),
      Self::Int => Some("Int"),
      Self::UInt => Some("UInt"),
      Self::Long => Some("Long"),
      Self::ULong => Some("ULong"),
      Self::Float => Some("Float"),
      Self::Double => Some("Double"),
      Self::ArrayByte => Some("ArrayByte"),
      Self::ArrayUByte => Some("ArrayUByte"),
      Self::ArrayShort => Some("ArrayShort"),
      Self::ArrayUShort => Some("ArrayUShort"),
      Self::ArrayInt => Some("ArrayInt"),
      Self::ArrayUInt => Some("ArrayUInt"),
      Self::ArrayLong => Some("ArrayLong"),
      Self::ArrayULong => Some("ArrayULong"),
      Self::ArrayFloat => Some("ArrayFloat"),
      Self::ArrayDouble => Some("ArrayDouble"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Value {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Value {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for Value {
    type Output = Value;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for Value {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Value {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Value {}
pub struct ValueUnionTableOffset {}

pub enum ByteOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Byte<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Byte<'a> {
  type Inner = Byte<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Byte<'a> {
  pub const VT_VALUE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Byte { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ByteArgs
  ) -> flatbuffers::WIPOffset<Byte<'bldr>> {
    let mut builder = ByteBuilder::new(_fbb);
    builder.add_value(args.value);
    builder.finish()
  }


  #[inline]
  pub fn value(&self) -> i8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(Byte::VT_VALUE, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Byte<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i8>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct ByteArgs {
    pub value: i8,
}
impl<'a> Default for ByteArgs {
  #[inline]
  fn default() -> Self {
    ByteArgs {
      value: 0,
    }
  }
}

pub struct ByteBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ByteBuilder<'a, 'b> {
  #[inline]
  pub fn add_value(&mut self, value: i8) {
    self.fbb_.push_slot::<i8>(Byte::VT_VALUE, value, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ByteBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ByteBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Byte<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Byte<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Byte");
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum UByteOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct UByte<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for UByte<'a> {
  type Inner = UByte<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> UByte<'a> {
  pub const VT_VALUE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    UByte { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args UByteArgs
  ) -> flatbuffers::WIPOffset<UByte<'bldr>> {
    let mut builder = UByteBuilder::new(_fbb);
    builder.add_value(args.value);
    builder.finish()
  }


  #[inline]
  pub fn value(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(UByte::VT_VALUE, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for UByte<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u8>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct UByteArgs {
    pub value: u8,
}
impl<'a> Default for UByteArgs {
  #[inline]
  fn default() -> Self {
    UByteArgs {
      value: 0,
    }
  }
}

pub struct UByteBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> UByteBuilder<'a, 'b> {
  #[inline]
  pub fn add_value(&mut self, value: u8) {
    self.fbb_.push_slot::<u8>(UByte::VT_VALUE, value, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> UByteBuilder<'a, 'b> {
    let start = _fbb.start_table();
    UByteBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<UByte<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for UByte<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("UByte");
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum ShortOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Short<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Short<'a> {
  type Inner = Short<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Short<'a> {
  pub const VT_VALUE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Short { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ShortArgs
  ) -> flatbuffers::WIPOffset<Short<'bldr>> {
    let mut builder = ShortBuilder::new(_fbb);
    builder.add_value(args.value);
    builder.finish()
  }


  #[inline]
  pub fn value(&self) -> i16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i16>(Short::VT_VALUE, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Short<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i16>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct ShortArgs {
    pub value: i16,
}
impl<'a> Default for ShortArgs {
  #[inline]
  fn default() -> Self {
    ShortArgs {
      value: 0,
    }
  }
}

pub struct ShortBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ShortBuilder<'a, 'b> {
  #[inline]
  pub fn add_value(&mut self, value: i16) {
    self.fbb_.push_slot::<i16>(Short::VT_VALUE, value, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ShortBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ShortBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Short<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Short<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Short");
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum UShortOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct UShort<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for UShort<'a> {
  type Inner = UShort<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> UShort<'a> {
  pub const VT_VALUE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    UShort { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args UShortArgs
  ) -> flatbuffers::WIPOffset<UShort<'bldr>> {
    let mut builder = UShortBuilder::new(_fbb);
    builder.add_value(args.value);
    builder.finish()
  }


  #[inline]
  pub fn value(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(UShort::VT_VALUE, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for UShort<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u16>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct UShortArgs {
    pub value: u16,
}
impl<'a> Default for UShortArgs {
  #[inline]
  fn default() -> Self {
    UShortArgs {
      value: 0,
    }
  }
}

pub struct UShortBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> UShortBuilder<'a, 'b> {
  #[inline]
  pub fn add_value(&mut self, value: u16) {
    self.fbb_.push_slot::<u16>(UShort::VT_VALUE, value, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> UShortBuilder<'a, 'b> {
    let start = _fbb.start_table();
    UShortBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<UShort<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for UShort<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("UShort");
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum IntOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Int<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Int<'a> {
  type Inner = Int<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Int<'a> {
  pub const VT_VALUE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Int { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args IntArgs
  ) -> flatbuffers::WIPOffset<Int<'bldr>> {
    let mut builder = IntBuilder::new(_fbb);
    builder.add_value(args.value);
    builder.finish()
  }


  #[inline]
  pub fn value(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Int::VT_VALUE, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Int<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct IntArgs {
    pub value: i32,
}
impl<'a> Default for IntArgs {
  #[inline]
  fn default() -> Self {
    IntArgs {
      value: 0,
    }
  }
}

pub struct IntBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> IntBuilder<'a, 'b> {
  #[inline]
  pub fn add_value(&mut self, value: i32) {
    self.fbb_.push_slot::<i32>(Int::VT_VALUE, value, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> IntBuilder<'a, 'b> {
    let start = _fbb.start_table();
    IntBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Int<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Int<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Int");
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum UIntOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct UInt<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for UInt<'a> {
  type Inner = UInt<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> UInt<'a> {
  pub const VT_VALUE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    UInt { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args UIntArgs
  ) -> flatbuffers::WIPOffset<UInt<'bldr>> {
    let mut builder = UIntBuilder::new(_fbb);
    builder.add_value(args.value);
    builder.finish()
  }


  #[inline]
  pub fn value(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(UInt::VT_VALUE, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for UInt<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct UIntArgs {
    pub value: u32,
}
impl<'a> Default for UIntArgs {
  #[inline]
  fn default() -> Self {
    UIntArgs {
      value: 0,
    }
  }
}

pub struct UIntBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> UIntBuilder<'a, 'b> {
  #[inline]
  pub fn add_value(&mut self, value: u32) {
    self.fbb_.push_slot::<u32>(UInt::VT_VALUE, value, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> UIntBuilder<'a, 'b> {
    let start = _fbb.start_table();
    UIntBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<UInt<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for UInt<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("UInt");
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum LongOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Long<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Long<'a> {
  type Inner = Long<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Long<'a> {
  pub const VT_VALUE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Long { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args LongArgs
  ) -> flatbuffers::WIPOffset<Long<'bldr>> {
    let mut builder = LongBuilder::new(_fbb);
    builder.add_value(args.value);
    builder.finish()
  }


  #[inline]
  pub fn value(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(Long::VT_VALUE, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Long<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i64>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct LongArgs {
    pub value: i64,
}
impl<'a> Default for LongArgs {
  #[inline]
  fn default() -> Self {
    LongArgs {
      value: 0,
    }
  }
}

pub struct LongBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> LongBuilder<'a, 'b> {
  #[inline]
  pub fn add_value(&mut self, value: i64) {
    self.fbb_.push_slot::<i64>(Long::VT_VALUE, value, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> LongBuilder<'a, 'b> {
    let start = _fbb.start_table();
    LongBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Long<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Long<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Long");
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum ULongOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ULong<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ULong<'a> {
  type Inner = ULong<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ULong<'a> {
  pub const VT_VALUE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ULong { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ULongArgs
  ) -> flatbuffers::WIPOffset<ULong<'bldr>> {
    let mut builder = ULongBuilder::new(_fbb);
    builder.add_value(args.value);
    builder.finish()
  }


  #[inline]
  pub fn value(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(ULong::VT_VALUE, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for ULong<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct ULongArgs {
    pub value: u64,
}
impl<'a> Default for ULongArgs {
  #[inline]
  fn default() -> Self {
    ULongArgs {
      value: 0,
    }
  }
}

pub struct ULongBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ULongBuilder<'a, 'b> {
  #[inline]
  pub fn add_value(&mut self, value: u64) {
    self.fbb_.push_slot::<u64>(ULong::VT_VALUE, value, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ULongBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ULongBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ULong<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ULong<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ULong");
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum FloatOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Float<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Float<'a> {
  type Inner = Float<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Float<'a> {
  pub const VT_VALUE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Float { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args FloatArgs
  ) -> flatbuffers::WIPOffset<Float<'bldr>> {
    let mut builder = FloatBuilder::new(_fbb);
    builder.add_value(args.value);
    builder.finish()
  }


  #[inline]
  pub fn value(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(Float::VT_VALUE, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Float<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f32>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct FloatArgs {
    pub value: f32,
}
impl<'a> Default for FloatArgs {
  #[inline]
  fn default() -> Self {
    FloatArgs {
      value: 0.0,
    }
  }
}

pub struct FloatBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FloatBuilder<'a, 'b> {
  #[inline]
  pub fn add_value(&mut self, value: f32) {
    self.fbb_.push_slot::<f32>(Float::VT_VALUE, value, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FloatBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FloatBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Float<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Float<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Float");
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum DoubleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Double<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Double<'a> {
  type Inner = Double<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Double<'a> {
  pub const VT_VALUE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Double { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args DoubleArgs
  ) -> flatbuffers::WIPOffset<Double<'bldr>> {
    let mut builder = DoubleBuilder::new(_fbb);
    builder.add_value(args.value);
    builder.finish()
  }


  #[inline]
  pub fn value(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Double::VT_VALUE, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Double<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f64>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct DoubleArgs {
    pub value: f64,
}
impl<'a> Default for DoubleArgs {
  #[inline]
  fn default() -> Self {
    DoubleArgs {
      value: 0.0,
    }
  }
}

pub struct DoubleBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DoubleBuilder<'a, 'b> {
  #[inline]
  pub fn add_value(&mut self, value: f64) {
    self.fbb_.push_slot::<f64>(Double::VT_VALUE, value, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DoubleBuilder<'a, 'b> {
    let start = _fbb.start_table();
    DoubleBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Double<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Double<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Double");
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum ArrayByteOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ArrayByte<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ArrayByte<'a> {
  type Inner = ArrayByte<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ArrayByte<'a> {
  pub const VT_VALUE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ArrayByte { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ArrayByteArgs<'args>
  ) -> flatbuffers::WIPOffset<ArrayByte<'bldr>> {
    let mut builder = ArrayByteBuilder::new(_fbb);
    if let Some(x) = args.value { builder.add_value(x); }
    builder.finish()
  }


  #[inline]
  pub fn value(&self) -> Option<flatbuffers::Vector<'a, i8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i8>>>(ArrayByte::VT_VALUE, None)}
  }
}

impl flatbuffers::Verifiable for ArrayByte<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i8>>>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct ArrayByteArgs<'a> {
    pub value: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i8>>>,
}
impl<'a> Default for ArrayByteArgs<'a> {
  #[inline]
  fn default() -> Self {
    ArrayByteArgs {
      value: None,
    }
  }
}

pub struct ArrayByteBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ArrayByteBuilder<'a, 'b> {
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ArrayByte::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ArrayByteBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ArrayByteBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ArrayByte<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ArrayByte<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ArrayByte");
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum ArrayUByteOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ArrayUByte<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ArrayUByte<'a> {
  type Inner = ArrayUByte<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ArrayUByte<'a> {
  pub const VT_VALUE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ArrayUByte { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ArrayUByteArgs<'args>
  ) -> flatbuffers::WIPOffset<ArrayUByte<'bldr>> {
    let mut builder = ArrayUByteBuilder::new(_fbb);
    if let Some(x) = args.value { builder.add_value(x); }
    builder.finish()
  }


  #[inline]
  pub fn value(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(ArrayUByte::VT_VALUE, None)}
  }
}

impl flatbuffers::Verifiable for ArrayUByte<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct ArrayUByteArgs<'a> {
    pub value: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for ArrayUByteArgs<'a> {
  #[inline]
  fn default() -> Self {
    ArrayUByteArgs {
      value: None,
    }
  }
}

pub struct ArrayUByteBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ArrayUByteBuilder<'a, 'b> {
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ArrayUByte::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ArrayUByteBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ArrayUByteBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ArrayUByte<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ArrayUByte<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ArrayUByte");
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum ArrayShortOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ArrayShort<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ArrayShort<'a> {
  type Inner = ArrayShort<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ArrayShort<'a> {
  pub const VT_VALUE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ArrayShort { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ArrayShortArgs<'args>
  ) -> flatbuffers::WIPOffset<ArrayShort<'bldr>> {
    let mut builder = ArrayShortBuilder::new(_fbb);
    if let Some(x) = args.value { builder.add_value(x); }
    builder.finish()
  }


  #[inline]
  pub fn value(&self) -> Option<flatbuffers::Vector<'a, i16>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i16>>>(ArrayShort::VT_VALUE, None)}
  }
}

impl flatbuffers::Verifiable for ArrayShort<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i16>>>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct ArrayShortArgs<'a> {
    pub value: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i16>>>,
}
impl<'a> Default for ArrayShortArgs<'a> {
  #[inline]
  fn default() -> Self {
    ArrayShortArgs {
      value: None,
    }
  }
}

pub struct ArrayShortBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ArrayShortBuilder<'a, 'b> {
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i16>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ArrayShort::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ArrayShortBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ArrayShortBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ArrayShort<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ArrayShort<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ArrayShort");
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum ArrayUShortOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ArrayUShort<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ArrayUShort<'a> {
  type Inner = ArrayUShort<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ArrayUShort<'a> {
  pub const VT_VALUE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ArrayUShort { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ArrayUShortArgs<'args>
  ) -> flatbuffers::WIPOffset<ArrayUShort<'bldr>> {
    let mut builder = ArrayUShortBuilder::new(_fbb);
    if let Some(x) = args.value { builder.add_value(x); }
    builder.finish()
  }


  #[inline]
  pub fn value(&self) -> Option<flatbuffers::Vector<'a, u16>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u16>>>(ArrayUShort::VT_VALUE, None)}
  }
}

impl flatbuffers::Verifiable for ArrayUShort<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u16>>>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct ArrayUShortArgs<'a> {
    pub value: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u16>>>,
}
impl<'a> Default for ArrayUShortArgs<'a> {
  #[inline]
  fn default() -> Self {
    ArrayUShortArgs {
      value: None,
    }
  }
}

pub struct ArrayUShortBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ArrayUShortBuilder<'a, 'b> {
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u16>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ArrayUShort::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ArrayUShortBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ArrayUShortBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ArrayUShort<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ArrayUShort<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ArrayUShort");
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum ArrayIntOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ArrayInt<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ArrayInt<'a> {
  type Inner = ArrayInt<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ArrayInt<'a> {
  pub const VT_VALUE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ArrayInt { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ArrayIntArgs<'args>
  ) -> flatbuffers::WIPOffset<ArrayInt<'bldr>> {
    let mut builder = ArrayIntBuilder::new(_fbb);
    if let Some(x) = args.value { builder.add_value(x); }
    builder.finish()
  }


  #[inline]
  pub fn value(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(ArrayInt::VT_VALUE, None)}
  }
}

impl flatbuffers::Verifiable for ArrayInt<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct ArrayIntArgs<'a> {
    pub value: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
}
impl<'a> Default for ArrayIntArgs<'a> {
  #[inline]
  fn default() -> Self {
    ArrayIntArgs {
      value: None,
    }
  }
}

pub struct ArrayIntBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ArrayIntBuilder<'a, 'b> {
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ArrayInt::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ArrayIntBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ArrayIntBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ArrayInt<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ArrayInt<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ArrayInt");
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum ArrayUIntOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ArrayUInt<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ArrayUInt<'a> {
  type Inner = ArrayUInt<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ArrayUInt<'a> {
  pub const VT_VALUE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ArrayUInt { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ArrayUIntArgs<'args>
  ) -> flatbuffers::WIPOffset<ArrayUInt<'bldr>> {
    let mut builder = ArrayUIntBuilder::new(_fbb);
    if let Some(x) = args.value { builder.add_value(x); }
    builder.finish()
  }


  #[inline]
  pub fn value(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(ArrayUInt::VT_VALUE, None)}
  }
}

impl flatbuffers::Verifiable for ArrayUInt<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct ArrayUIntArgs<'a> {
    pub value: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
}
impl<'a> Default for ArrayUIntArgs<'a> {
  #[inline]
  fn default() -> Self {
    ArrayUIntArgs {
      value: None,
    }
  }
}

pub struct ArrayUIntBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ArrayUIntBuilder<'a, 'b> {
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ArrayUInt::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ArrayUIntBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ArrayUIntBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ArrayUInt<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ArrayUInt<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ArrayUInt");
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum ArrayLongOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ArrayLong<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ArrayLong<'a> {
  type Inner = ArrayLong<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ArrayLong<'a> {
  pub const VT_VALUE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ArrayLong { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ArrayLongArgs<'args>
  ) -> flatbuffers::WIPOffset<ArrayLong<'bldr>> {
    let mut builder = ArrayLongBuilder::new(_fbb);
    if let Some(x) = args.value { builder.add_value(x); }
    builder.finish()
  }


  #[inline]
  pub fn value(&self) -> Option<flatbuffers::Vector<'a, i64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i64>>>(ArrayLong::VT_VALUE, None)}
  }
}

impl flatbuffers::Verifiable for ArrayLong<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i64>>>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct ArrayLongArgs<'a> {
    pub value: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i64>>>,
}
impl<'a> Default for ArrayLongArgs<'a> {
  #[inline]
  fn default() -> Self {
    ArrayLongArgs {
      value: None,
    }
  }
}

pub struct ArrayLongBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ArrayLongBuilder<'a, 'b> {
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ArrayLong::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ArrayLongBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ArrayLongBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ArrayLong<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ArrayLong<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ArrayLong");
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum ArrayULongOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ArrayULong<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ArrayULong<'a> {
  type Inner = ArrayULong<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ArrayULong<'a> {
  pub const VT_VALUE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ArrayULong { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ArrayULongArgs<'args>
  ) -> flatbuffers::WIPOffset<ArrayULong<'bldr>> {
    let mut builder = ArrayULongBuilder::new(_fbb);
    if let Some(x) = args.value { builder.add_value(x); }
    builder.finish()
  }


  #[inline]
  pub fn value(&self) -> Option<flatbuffers::Vector<'a, u64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u64>>>(ArrayULong::VT_VALUE, None)}
  }
}

impl flatbuffers::Verifiable for ArrayULong<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u64>>>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct ArrayULongArgs<'a> {
    pub value: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u64>>>,
}
impl<'a> Default for ArrayULongArgs<'a> {
  #[inline]
  fn default() -> Self {
    ArrayULongArgs {
      value: None,
    }
  }
}

pub struct ArrayULongBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ArrayULongBuilder<'a, 'b> {
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ArrayULong::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ArrayULongBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ArrayULongBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ArrayULong<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ArrayULong<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ArrayULong");
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum ArrayFloatOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ArrayFloat<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ArrayFloat<'a> {
  type Inner = ArrayFloat<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ArrayFloat<'a> {
  pub const VT_VALUE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ArrayFloat { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ArrayFloatArgs<'args>
  ) -> flatbuffers::WIPOffset<ArrayFloat<'bldr>> {
    let mut builder = ArrayFloatBuilder::new(_fbb);
    if let Some(x) = args.value { builder.add_value(x); }
    builder.finish()
  }


  #[inline]
  pub fn value(&self) -> Option<flatbuffers::Vector<'a, f32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(ArrayFloat::VT_VALUE, None)}
  }
}

impl flatbuffers::Verifiable for ArrayFloat<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct ArrayFloatArgs<'a> {
    pub value: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
}
impl<'a> Default for ArrayFloatArgs<'a> {
  #[inline]
  fn default() -> Self {
    ArrayFloatArgs {
      value: None,
    }
  }
}

pub struct ArrayFloatBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ArrayFloatBuilder<'a, 'b> {
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ArrayFloat::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ArrayFloatBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ArrayFloatBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ArrayFloat<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ArrayFloat<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ArrayFloat");
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum ArrayDoubleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ArrayDouble<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ArrayDouble<'a> {
  type Inner = ArrayDouble<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ArrayDouble<'a> {
  pub const VT_VALUE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ArrayDouble { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ArrayDoubleArgs<'args>
  ) -> flatbuffers::WIPOffset<ArrayDouble<'bldr>> {
    let mut builder = ArrayDoubleBuilder::new(_fbb);
    if let Some(x) = args.value { builder.add_value(x); }
    builder.finish()
  }


  #[inline]
  pub fn value(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(ArrayDouble::VT_VALUE, None)}
  }
}

impl flatbuffers::Verifiable for ArrayDouble<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct ArrayDoubleArgs<'a> {
    pub value: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
}
impl<'a> Default for ArrayDoubleArgs<'a> {
  #[inline]
  fn default() -> Self {
    ArrayDoubleArgs {
      value: None,
    }
  }
}

pub struct ArrayDoubleBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ArrayDoubleBuilder<'a, 'b> {
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ArrayDouble::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ArrayDoubleBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ArrayDoubleBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ArrayDouble<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ArrayDouble<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ArrayDouble");
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum f144_LogDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct f144_LogData<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for f144_LogData<'a> {
  type Inner = f144_LogData<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> f144_LogData<'a> {
  pub const VT_SOURCE_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 6;
  pub const VT_VALUE_TYPE: flatbuffers::VOffsetT = 8;
  pub const VT_VALUE: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    f144_LogData { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args f144_LogDataArgs<'args>
  ) -> flatbuffers::WIPOffset<f144_LogData<'bldr>> {
    let mut builder = f144_LogDataBuilder::new(_fbb);
    builder.add_timestamp(args.timestamp);
    if let Some(x) = args.value { builder.add_value(x); }
    if let Some(x) = args.source_name { builder.add_source_name(x); }
    builder.add_value_type(args.value_type);
    builder.finish()
  }


  #[inline]
  pub fn source_name(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(f144_LogData::VT_SOURCE_NAME, None).unwrap()}
  }
  #[inline]
  pub fn timestamp(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(f144_LogData::VT_TIMESTAMP, Some(0)).unwrap()}
  }
  #[inline]
  pub fn value_type(&self) -> Value {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Value>(f144_LogData::VT_VALUE_TYPE, Some(Value::NONE)).unwrap()}
  }
  #[inline]
  pub fn value(&self) -> flatbuffers::Table<'a> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(f144_LogData::VT_VALUE, None).unwrap()}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn value_as_byte(&self) -> Option<Byte<'a>> {
    if self.value_type() == Value::Byte {
      let u = self.value();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { Byte::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn value_as_ubyte(&self) -> Option<UByte<'a>> {
    if self.value_type() == Value::UByte {
      let u = self.value();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { UByte::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn value_as_short(&self) -> Option<Short<'a>> {
    if self.value_type() == Value::Short {
      let u = self.value();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { Short::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn value_as_ushort(&self) -> Option<UShort<'a>> {
    if self.value_type() == Value::UShort {
      let u = self.value();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { UShort::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn value_as_int(&self) -> Option<Int<'a>> {
    if self.value_type() == Value::Int {
      let u = self.value();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { Int::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn value_as_uint(&self) -> Option<UInt<'a>> {
    if self.value_type() == Value::UInt {
      let u = self.value();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { UInt::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn value_as_long(&self) -> Option<Long<'a>> {
    if self.value_type() == Value::Long {
      let u = self.value();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { Long::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn value_as_ulong(&self) -> Option<ULong<'a>> {
    if self.value_type() == Value::ULong {
      let u = self.value();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { ULong::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn value_as_float(&self) -> Option<Float<'a>> {
    if self.value_type() == Value::Float {
      let u = self.value();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { Float::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn value_as_double(&self) -> Option<Double<'a>> {
    if self.value_type() == Value::Double {
      let u = self.value();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { Double::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn value_as_array_byte(&self) -> Option<ArrayByte<'a>> {
    if self.value_type() == Value::ArrayByte {
      let u = self.value();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { ArrayByte::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn value_as_array_ubyte(&self) -> Option<ArrayUByte<'a>> {
    if self.value_type() == Value::ArrayUByte {
      let u = self.value();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { ArrayUByte::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn value_as_array_short(&self) -> Option<ArrayShort<'a>> {
    if self.value_type() == Value::ArrayShort {
      let u = self.value();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { ArrayShort::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn value_as_array_ushort(&self) -> Option<ArrayUShort<'a>> {
    if self.value_type() == Value::ArrayUShort {
      let u = self.value();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { ArrayUShort::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn value_as_array_int(&self) -> Option<ArrayInt<'a>> {
    if self.value_type() == Value::ArrayInt {
      let u = self.value();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { ArrayInt::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn value_as_array_uint(&self) -> Option<ArrayUInt<'a>> {
    if self.value_type() == Value::ArrayUInt {
      let u = self.value();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { ArrayUInt::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn value_as_array_long(&self) -> Option<ArrayLong<'a>> {
    if self.value_type() == Value::ArrayLong {
      let u = self.value();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { ArrayLong::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn value_as_array_ulong(&self) -> Option<ArrayULong<'a>> {
    if self.value_type() == Value::ArrayULong {
      let u = self.value();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { ArrayULong::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn value_as_array_float(&self) -> Option<ArrayFloat<'a>> {
    if self.value_type() == Value::ArrayFloat {
      let u = self.value();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { ArrayFloat::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn value_as_array_double(&self) -> Option<ArrayDouble<'a>> {
    if self.value_type() == Value::ArrayDouble {
      let u = self.value();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { ArrayDouble::init_from_table(u) })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for f144_LogData<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("source_name", Self::VT_SOURCE_NAME, true)?
     .visit_field::<i64>("timestamp", Self::VT_TIMESTAMP, false)?
     .visit_union::<Value, _>("value_type", Self::VT_VALUE_TYPE, "value", Self::VT_VALUE, true, |key, v, pos| {
        match key {
          Value::Byte => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Byte>>("Value::Byte", pos),
          Value::UByte => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UByte>>("Value::UByte", pos),
          Value::Short => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Short>>("Value::Short", pos),
          Value::UShort => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UShort>>("Value::UShort", pos),
          Value::Int => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Int>>("Value::Int", pos),
          Value::UInt => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UInt>>("Value::UInt", pos),
          Value::Long => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Long>>("Value::Long", pos),
          Value::ULong => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ULong>>("Value::ULong", pos),
          Value::Float => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Float>>("Value::Float", pos),
          Value::Double => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Double>>("Value::Double", pos),
          Value::ArrayByte => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ArrayByte>>("Value::ArrayByte", pos),
          Value::ArrayUByte => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ArrayUByte>>("Value::ArrayUByte", pos),
          Value::ArrayShort => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ArrayShort>>("Value::ArrayShort", pos),
          Value::ArrayUShort => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ArrayUShort>>("Value::ArrayUShort", pos),
          Value::ArrayInt => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ArrayInt>>("Value::ArrayInt", pos),
          Value::ArrayUInt => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ArrayUInt>>("Value::ArrayUInt", pos),
          Value::ArrayLong => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ArrayLong>>("Value::ArrayLong", pos),
          Value::ArrayULong => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ArrayULong>>("Value::ArrayULong", pos),
          Value::ArrayFloat => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ArrayFloat>>("Value::ArrayFloat", pos),
          Value::ArrayDouble => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ArrayDouble>>("Value::ArrayDouble", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct f144_LogDataArgs<'a> {
    pub source_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub timestamp: i64,
    pub value_type: Value,
    pub value: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for f144_LogDataArgs<'a> {
  #[inline]
  fn default() -> Self {
    f144_LogDataArgs {
      source_name: None, // required field
      timestamp: 0,
      value_type: Value::NONE,
      value: None, // required field
    }
  }
}

pub struct f144_LogDataBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> f144_LogDataBuilder<'a, 'b> {
  #[inline]
  pub fn add_source_name(&mut self, source_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(f144_LogData::VT_SOURCE_NAME, source_name);
  }
  #[inline]
  pub fn add_timestamp(&mut self, timestamp: i64) {
    self.fbb_.push_slot::<i64>(f144_LogData::VT_TIMESTAMP, timestamp, 0);
  }
  #[inline]
  pub fn add_value_type(&mut self, value_type: Value) {
    self.fbb_.push_slot::<Value>(f144_LogData::VT_VALUE_TYPE, value_type, Value::NONE);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(f144_LogData::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> f144_LogDataBuilder<'a, 'b> {
    let start = _fbb.start_table();
    f144_LogDataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<f144_LogData<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, f144_LogData::VT_SOURCE_NAME,"source_name");
    self.fbb_.required(o, f144_LogData::VT_VALUE,"value");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for f144_LogData<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("f144_LogData");
      ds.field("source_name", &self.source_name());
      ds.field("timestamp", &self.timestamp());
      ds.field("value_type", &self.value_type());
      match self.value_type() {
        Value::Byte => {
          if let Some(x) = self.value_as_byte() {
            ds.field("value", &x)
          } else {
            ds.field("value", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Value::UByte => {
          if let Some(x) = self.value_as_ubyte() {
            ds.field("value", &x)
          } else {
            ds.field("value", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Value::Short => {
          if let Some(x) = self.value_as_short() {
            ds.field("value", &x)
          } else {
            ds.field("value", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Value::UShort => {
          if let Some(x) = self.value_as_ushort() {
            ds.field("value", &x)
          } else {
            ds.field("value", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Value::Int => {
          if let Some(x) = self.value_as_int() {
            ds.field("value", &x)
          } else {
            ds.field("value", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Value::UInt => {
          if let Some(x) = self.value_as_uint() {
            ds.field("value", &x)
          } else {
            ds.field("value", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Value::Long => {
          if let Some(x) = self.value_as_long() {
            ds.field("value", &x)
          } else {
            ds.field("value", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Value::ULong => {
          if let Some(x) = self.value_as_ulong() {
            ds.field("value", &x)
          } else {
            ds.field("value", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Value::Float => {
          if let Some(x) = self.value_as_float() {
            ds.field("value", &x)
          } else {
            ds.field("value", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Value::Double => {
          if let Some(x) = self.value_as_double() {
            ds.field("value", &x)
          } else {
            ds.field("value", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Value::ArrayByte => {
          if let Some(x) = self.value_as_array_byte() {
            ds.field("value", &x)
          } else {
            ds.field("value", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Value::ArrayUByte => {
          if let Some(x) = self.value_as_array_ubyte() {
            ds.field("value", &x)
          } else {
            ds.field("value", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Value::ArrayShort => {
          if let Some(x) = self.value_as_array_short() {
            ds.field("value", &x)
          } else {
            ds.field("value", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Value::ArrayUShort => {
          if let Some(x) = self.value_as_array_ushort() {
            ds.field("value", &x)
          } else {
            ds.field("value", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Value::ArrayInt => {
          if let Some(x) = self.value_as_array_int() {
            ds.field("value", &x)
          } else {
            ds.field("value", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Value::ArrayUInt => {
          if let Some(x) = self.value_as_array_uint() {
            ds.field("value", &x)
          } else {
            ds.field("value", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Value::ArrayLong => {
          if let Some(x) = self.value_as_array_long() {
            ds.field("value", &x)
          } else {
            ds.field("value", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Value::ArrayULong => {
          if let Some(x) = self.value_as_array_ulong() {
            ds.field("value", &x)
          } else {
            ds.field("value", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Value::ArrayFloat => {
          if let Some(x) = self.value_as_array_float() {
            ds.field("value", &x)
          } else {
            ds.field("value", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Value::ArrayDouble => {
          if let Some(x) = self.value_as_array_double() {
            ds.field("value", &x)
          } else {
            ds.field("value", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("value", &x)
        },
      };
      ds.finish()
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `f144_LogData`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_f_144_log_data_unchecked`.
pub fn root_as_f_144_log_data(buf: &[u8]) -> Result<f144_LogData, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<f144_LogData>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `f144_LogData` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_f_144_log_data_unchecked`.
pub fn size_prefixed_root_as_f_144_log_data(buf: &[u8]) -> Result<f144_LogData, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<f144_LogData>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `f144_LogData` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_f_144_log_data_unchecked`.
pub fn root_as_f_144_log_data_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<f144_LogData<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<f144_LogData<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `f144_LogData` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_f_144_log_data_unchecked`.
pub fn size_prefixed_root_as_f_144_log_data_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<f144_LogData<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<f144_LogData<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a f144_LogData and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `f144_LogData`.
pub unsafe fn root_as_f_144_log_data_unchecked(buf: &[u8]) -> f144_LogData {
  flatbuffers::root_unchecked::<f144_LogData>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed f144_LogData and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `f144_LogData`.
pub unsafe fn size_prefixed_root_as_f_144_log_data_unchecked(buf: &[u8]) -> f144_LogData {
  flatbuffers::size_prefixed_root_unchecked::<f144_LogData>(buf)
}
pub const F_144_LOG_DATA_IDENTIFIER: &str = "f144";

#[inline]
pub fn f_144_log_data_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, F_144_LOG_DATA_IDENTIFIER, false)
}

#[inline]
pub fn f_144_log_data_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, F_144_LOG_DATA_IDENTIFIER, true)
}

#[inline]
pub fn finish_f_144_log_data_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<f144_LogData<'a>>) {
  fbb.finish(root, Some(F_144_LOG_DATA_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_f_144_log_data_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<f144_LogData<'a>>) {
  fbb.finish_size_prefixed(root, Some(F_144_LOG_DATA_IDENTIFIER));
}
